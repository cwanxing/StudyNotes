如果忘了，可以查看.html 文件，不过得按顺序下来哦
1. let 替换 var
    var：缺点是存在变量提升
    let：解决了变量提升问题

2. 凡是区块内使用 let const 声明的变量，在它之前引用它，报错

3. 暂时性死区：进入当前作用域，所需的变量只读，只有声明变量那一行代码出现。才能获取和使用

4. let 不允许在相同作用域内，重复声明同一个变量

5. let 实际上为JavaScript新增了块集作用域

6. ES6 引入块级作用域，并可以在块级作用域中声明函数，并且不会在作用域中访问到
   ES5 中函数只能在函数和顶级作用域中声明，不能在块级作用域中声明

7. 因为块级作用域与函数声明之间的这种变化，所以应该尽量避免使用。若需要，可以使用函数表达式代替

8. const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动

9. ES6 能表示数组的数据结构：Array, Object【类数组】, Set【ES6】，Map【ES6】

10. Map 数据结构：不仅可以键<==>值，还可以值<==>值，可以不管键的数据类型【对象的键只能是字符串：{name: 1, age: 12}】

11. 一个对象的键只能是字符串或者Symbols【ES6 新创的数据类型】，但一个Map的键可以是任意值

12. 解构赋值允许指定默认值 let [x, y = 'b'] = ['a']; // x='a', y='b'

13. 只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错
    let { prop: x } = undefined; // TypeError       let { prop: y } = null; // TypeError

14. 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历

15. JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节

16. codePointAt正确返回 32 位的 UTF-16 字符的码点(汉字)。对于两个字节储存的常规字符(非汉字)，它的返回结果与charCodeAt方法相同

17. ES6中 fromCodePoint 方法定义在 String 对象上，而 codePointAt 方法定义在字符串的实例对象上

18. 遍历器最大的优点：可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点

19. JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中

20. repeat方法返回一个新字符串，表示将原字符串重复n次

21. 使用模板字符串【反引号 英文输入法下，Tab键上】表示多行字符串，所有的【空格和缩进】都会被保留在输出之中

22. 标签模板不是模板，而是函数调用的一种【特殊形式】。“标签”指的就是函数，紧跟在后面的模板字符串就是参数：alert`3`=>alert(3)

23. 模板处理函数的第一个参数（模板字符串数组），都有一个raw属性【保存的是转义后的原字符串】

24. String.raw方法可作为处理【模板字符串】的基本方法，它会将所有变量替换，且对斜杠转义，方便下面作为字符串来使用

25. ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示

26. ES6 引入 rest 参数（形式为 ...变量名），用于获取函数的【多余参数】这样就不需要使用arguments对象了

27. ES2016 修改规定: 只要函数参数使用了【默认值/解构赋值/扩展运算符】那么函数内部就【不能显式】设定为严格模式，否则会报错

28. 为函数参数设置默认值后，函数的length属性：返回那些没有设置默认值参数的个数

29. 为函数参数设置默认值，在函数声明初始化时，参数会自动创建一个作用域，直至初始化结束。没设默认值忽略

30. 箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）

31. 只有不再用到【外部函数】的【内部变量】，【内层函数】的调用帧才会取代【外层函数】的调用帧；否则无法尾调用优化

32. 需要知道直接复制一个数组，只是复制了指向这个数组的指向，而并非克隆整个数组

33. 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符【...】

34. ES5 的对象属性名都是字符串，这容易造成属性名的冲突

35. ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this

36. 向 Set 加入值的时候，不会发生类型转换，所以5和"5"是两个不同的值

37. Set 结构的实例默认可遍历，它的默认【遍历器生成函数】就是它的values方法

38. Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键