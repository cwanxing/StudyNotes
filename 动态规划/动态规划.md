> 题目：
    有10阶楼梯，现在让你从下往上走，且每跨一步只能向上 1阶 或 2阶
    
> 要求：
    用程序求出一公有多少种走法
    
    注：具体效果看图1，图2
 
>不用动态规划：
    多层嵌套，遍历所有可能；计时器 + 1
    坏处：太耗内存了【专业说：时间复杂度是程指数级增长的】
    
>使用动态规划【Dynamic Programmaing】
    1. 最优子结构
    2. 边界
    3. 状态转移公式【方程】
 
# 1. 假设你只差最后一步，那么就只有两种情况
    一步 ： 从 9阶 --> 10阶
    两步 ： 从 8阶 --> 10阶
    
# 2. 设前面 0-9 阶有 X 种走法；0-8 阶有 Y 种走法 
      可以得出 0-10 阶：
        到第 10 阶【最后一步】即从8 或 9 阶开始走
        而前面的 0-8、 0-9 阶走法是 X Y
        
      那么0-10 阶的所有走法：【可以根据最后一步分为来计算】
        1. 9-10 和 0-9 走法一样 X
        2. 9-10 和 0-8 走法一样 Y
        注：这里要好好理解
        【比如0-9 走法有X 种，想象一下，这时只剩下一阶了，注意不是 X+1 哦，】
        【可以这么理解：假设你用第 10 种方法走到了第 9 阶，那么这最后一阶，你觉得它属于第几种方法呢？？？】
        【不用说，肯定是属于第 10 种了， 联想一下。要有X 种呢？？ 想通了么】
    
    所有得出全部走法有 X+Y 种【看图 怎么得出X+Y的】
    
# 3. 0-10 阶走法 = 0-9 阶走法 + 0-8 阶走法
     F(10) = F(9) + F(8) ?

# 4. 计算 F(9) / F(8)
        回到第2步，则
            F(9) = F(8) + F(7) ; F(8) = F(7) + F(6) ; F(7) = F(6) + F(5)
            
# 5. 当只有两阶时，走法有2 种
        一步 2 阶、一步 1阶

> 得出公式：F(1) = 1; F(2) = 2; F(n) = F(n-1) + F(n-2) 【n >= 3】
    
    * 1. 最优子结构
         F(9) 和 F(8) 是 F(10) 的最优子结构
         F(7) 和 F(8) 是 F(9) 的最优子结构
            .
         以此类推
                  
    * 2. 边界
         当台阶只有 1 台或 2 台时，不用计算，直接得出结果
         就称：F(1) 和 F(2) 是该问题的边界
         注：如果一个问题没有边界，那么该问题就没有有限的结果【无解 类似】
         
    * 3. 状态转移过程 * 核心 *
        F(n) = F(n-1) + F(n-2) 就是该问题的状态转移方程

以上是动态规划的【问题建模】

解决问题：
    以下是我直接复制的代码【代码是看懂了，就是不知道问啥这么写】只能以后多用了
    
    命名：递归算法
    
    * C 语言 
    `
    int getClimbingWays(int n){
        if(n < 1){
            return 0;
        }
        if(n == 1){
            return 1;
        }
        if(n == 2){
            return 2;
        }
        if(n >= 3){
            return getClimbingWays(n-1) + getClimbingWays(n-2);
            //    F(n-1) + F(n-2) => F(n)
        }
    }
    `
    【以下是关于时间复杂度计算和优化过程】尽力了
    
    # 1. 要计算F(n) 得算出 F(n-1) 和 F(n-2)
         计算F(n-1) 得算出 F(n-2) 和 F(n-3)
            .
            类推
       由此形成了二叉树【具体看图 时间复杂度计算】
    
    # 2. 该二叉树的节点数量就是上面的递归方法计算的次数【以下介绍的可能看不懂了】
           二叉树高度为 n-1
           节点数量接近 2 的 n-1 次方
          得出时间复杂度：O(2^n)【2的 n 次方，理解：阶数越多，此递归方法的计算量是成 次方形增长的】
          * 感觉时间复杂度 就是这个用
    
问题优化：【查看优化.jpg】优化 时间复杂度
    有重复的参数被重复计算了，越下面越多
    
    解决：使用缓存【利用到哈希表】
        1. 每次计算，判断往哈希表里存入不同的数
        2. 等再次遇到相同的值时，直接从哈希表里取就可以了
        
    命名：备忘录算法
    
     `
    int getClimbingWays(int n, HashMap<Integer, Integer> map){
        if(n < 1){
            return 0;
        }
        if(n == 1){
            return 1;
        }
        if(n == 2){
            return 2;
        }
        // map 就是存放
        if(map.contains(n)){
            return map.get(n);
        }else{
            int value = getClimbingWays(n-1) + getClimbingWays(n-2);
            map.put(n, value);
            return value;
        }
    }
    
     `
问题优化：【查看优化.jpg】优化 空间复杂度 用更小的内存
    逆向思维【真不懂】
    迭代法：就好像替换变量内的值【比如通过循环出来的新值，则用该变量去存它，这过程中，始终只用到该变量】
    
    问题：前面的解法都是从第10 阶开始，不妨我们从1 阶开始试试
    
    过程：自下而上
        第一行：台阶数量
        第二行：几种走法 
           
        # 1. 图一 二阶
            解释：走法是 2 种
                F(1) = 1; F(2) = 2
                
        # 2. 图二 三阶
            解释：走法是 3 种
                F(3) = F(1) + F(2) 
                三阶的时候：它的结果是一阶结果 + 二阶结果
                
        # 3. 图三 四阶
            解释：走法是 5 种
                F(4) = F(2) + F(3)
                四阶的时候：它的结果是二阶结果 + 三阶结果
        
        # 4. 图四 五阶
            解释：走法是 8 种
                F(5) = F(4) + F(4)
                五阶的时候：它的结果是三阶结果 + 四阶结果
                
    结论：
        当阶数大于三的时候，每个阶的数量就是前面两个阶数的走法之和
        换个说法：它始终依赖前两阶的数量
    
    思考：
        我们可不可以 让哈希表只保存当前阶数的前两个阶数的走法数【当然这个过程是累加来的】
        不用保存全部的走法
    
    代码：
    `
    int getClimbingWays(int n, HashMap<Integer, Integer> map){
        if(n < 1){
            return 0;
        }
        if(n == 1){
            return 1;
        }
        if(n == 2){
            return 2;
        }
        int a = 1; // 一阶
        int b = 2; // 二阶
        int temp = 0; // 存放前面两阶两种走法数量
        
        for(int i = 3; i <= n; i++){
            temp = a + b;
            a = b;
            b = temp;
        }
        return temp;
        
    }
    
    `
          
        
    
    
    